# -*- coding: utf-8 -*-
"""Currency2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FylN9RdzjJB_YhokLmnXLsnrpwNgDstG
"""
import prophet

import warnings
warnings.filterwarnings('ignore')

"""Without cross-validation"""

from prophet import Prophet as p
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.model_selection import train_test_split
from statsmodels.iolib.smpickle import save_pickle
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import TimeSeriesSplit
import pickle

df1=pd.read_csv('data1.csv')
df2=pd.read_csv('data2.csv')
df1=df1[::-1]
df2=df2[::-1]

df=pd.concat([df1,df2])

# df=pd.read_csv('updated_currency_rates.csv')

df=df.reset_index()

df.drop(['index','Vol.'],axis=1,inplace=True)

df.head()

print(len(df))

df.rename(columns={'Date':'ds','Price':'y'},inplace=True)

df.head()

df['ds'] = pd.to_datetime(df['ds'])
df.head()

# Split the data into train and test sets
# train_data, test_data = train_test_split(df, test_size=0.3, shuffle=False)
train_data = df[:-1100]
test_data = df[-1100:]

model = p(n_changepoints=8, changepoint_prior_scale=0.1)
model = model.fit(train_data)

# Make predictions for train and test sets
train_predictions = model.predict(train_data)
test_predictions = model.predict(test_data)

# Extract the actual values and predicted values for train and test sets
train_actual = train_data['y'].values
train_predicted = train_predictions['yhat'].values[:len(train_data)]
test_actual = test_data['y'].values
test_predicted = test_predictions['yhat'].values[-len(test_data):]

print(test_actual)
print()
print(test_predicted)

future=model.make_future_dataframe(periods=50)

forecast=model.predict(future)

# forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]

model.plot(forecast)
plt.xlabel('Date')
plt.ylabel('Value')
plt.title("Time Series Forecast")
# plt.show()

# Calculate RMSE and MSE for train set
train_rmse = np.sqrt(mean_squared_error(train_actual, train_predicted))
train_mse = mean_squared_error(train_actual, train_predicted)

# Calculate RMSE and MSE for test set
test_rmse = np.sqrt(mean_squared_error(test_actual, test_predicted))
test_mse = mean_squared_error(test_actual, test_predicted)

print("The R2 score on the Train set is:\t{:0.3f}".format(r2_score(train_actual, train_predicted)))
print("The  MAE on the Train set is:\t{:0.3f}".format(mean_absolute_error(train_actual, train_predicted)))
print("The  RMSE on the Train set is:\t{:0.3f}".format(np.sqrt(mean_squared_error(train_actual, train_predicted))))
print()
print("The R2 score on the Test set is:\t{:0.3f}".format(r2_score(test_actual, test_predicted)))
print("The  MAE on the Test set is:\t{:0.3f}".format(mean_absolute_error(test_actual, test_predicted)))
print("The  RMSE on the Test set is:\t{:0.3f}".format(np.sqrt(mean_squared_error(test_actual, test_predicted))))

def future_rates(edate):
  last_date = test_data['ds'].iloc[-1]
  edate = pd.to_datetime(edate)
  nd = abs(edate - last_date)
  nd = nd.days
  prediction_date = last_date + pd.DateOffset(days = nd)
  future = pd.date_range(start = last_date + pd.DateOffset(days=1), end = prediction_date, freq = 'D')
  future = pd.DataFrame({'ds':future})

  forecast = model.predict(future)
  return forecast.yhat_upper.iloc[-1]

# def show_graph(edate):
#   edate=pd.to_datetime(edate)
#   last_date=edate-pd.Timedelta(days=15)
#   plot_df=test_data.loc[test_data['ds']>= last_date]
#   future = pd.date_range(start = plot_df['ds'].iloc[-1] +pd.DateOffset(days=1), end = edate, freq = 'D')
#   future = pd.DataFrame({'ds':future})
#   forecast = model.predict(future)
#   future_df=pd.DataFrame(forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']])
  # y_axis=plot_df['y']
  # y_axis.concat(future_df['yhat_upper'])
  # x_axis=plot_df['ds']
  # x_axis.concat(future_df['ds'])
  # plt.plot(x_axis,y_axis)
  # plt.xticks(x_axis,rotation=90)
  # plt.show()


# predicted = future_rates('2023-5-10')
# predicted
save_pickle(model, 'currency2.pkl')
pickle.dump(model, open('currency2.pkl', 'wb'))




