# -*- coding: utf-8 -*-
"""arima2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fjrbkzSriYaBr3NQ1wditHsDKOysHa9_
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.iolib.smpickle import save_pickle
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.arima.model import ARIMAResults
from sklearn.metrics import mean_squared_error, mean_absolute_error
from math import sqrt
import time
import warnings
import pickle

warnings.filterwarnings('ignore')

# read the data
file = "updated_currency_rates.csv"
df = pd.read_csv(file, index_col='ds', parse_dates=True)
# df

df.tail(15)

# extract the univariate series
variable_to_predict = df['y']
# variable_to_predict

# plot the series
plt.figure(figsize=(12,5))
plt.plot(variable_to_predict)
plt.grid(True)
# plt.show

# Augmented Dickey-Fuller test for staionarity
result = adfuller(variable_to_predict)
print('ADF Statistic: %f' % result[0])
print('p-value: %f' % result[1])
print('Critical Values:')
for key, value in result[4].items():
    print('\t%s: %.3f' % (key, value))

# the series is not stationary since p-value > 0.05

# get the differences of the observations for stationarity
variable_to_predict_diff1 = variable_to_predict.diff()
# variable_to_predict_diff1
# first row should be dropped due to the NaN value

# drop the NaN row
variable_to_predict_diff1.dropna(inplace=True)
# variable_to_predict_diff1
# now the series has one less row

# plot the series again to observe stationarity
plt.figure(figsize=(12,4))
plt.grid(True)
plt.plot(variable_to_predict_diff1)
# plt.show

# check again to see if the series gets stationary
result = adfuller(variable_to_predict_diff1, regression='ctt')
print('ADF Statistic: %f' % result[0])
print('p-value: %f' % result[1])
print('Critical Values:')
for key, value in result[4].items():
    print('\t%s: %.3f' % (key, value))

# plot the autocorrelation and partial autocorrelation
# this tells us about the AR(p) and MA(q) values
acf = plot_acf(variable_to_predict_diff1)
plt.ylim(-0.05,0.05)
pacf = plot_pacf(variable_to_predict_diff1)
plt.ylim(-0.05,0.05)

"""Cross Validation using Rolling Split"""

window_size = 30  # number of days in each split
stride = 7  # number of days to move forward for each split

train_data = []
test_data = []

predictions = []
test_data_list = []

# perform rolling window split and make predictions
for i in range(0, len(variable_to_predict) - window_size + 1, stride):
    train_data = variable_to_predict.iloc[i:i+window_size]
    test_data = variable_to_predict.iloc[i+window_size:i+window_size+stride]

    # fit the ARIMA model on the training data
    model = ARIMA(train_data, order=(1, 1, 1))
    results = model.fit()

    # make predictions on the test data
    forecast = results.forecast(steps=len(test_data))

    # append the forecasted values to the list
    predictions.extend(forecast)
    test_data_list.extend(test_data)

#predictions = pd.Series(predictions, index=pd.Index(test_data_list))
# print(predictions)

#test_data = pd.Series(test_data_list, index=pd.Index(test_data_list))
# print(test_data_list)

# evaluate the predictions against the actual values
mae = mean_absolute_error(test_data_list, predictions)
mse = mean_squared_error(test_data_list, predictions)
rmse = np.sqrt(mse)
print("MAE Value: ", mae)
print("RMSE Value: ", rmse)

# plot the actual test and predicted values
# plt.figure(figsize=(12,5))
# plt.plot(variable_to_predict.iloc[-1000:].index, test_data_list[-1000:], color='blue')
# plt.plot(variable_to_predict.iloc[-1000:].index, predictions[-1000:], color='red')
# plt.legend(('INR Actual', 'INR Predictions'))
# plt.xticks(variable_to_predict.iloc[-1000::20].index, rotation = 90)
# plt.show()

"""Future out-of-sample predictions"""

def future_rate(edate):
    sdate = pd.to_datetime('2023-05-03')
    edate = pd.to_datetime(edate)
    nd = abs(sdate-edate)
    nd = nd.days
    pred = results.forecast(steps=nd, frequency='d')
    # print(pred)
    return pred.iloc[-1]

# pred = future_rate('2023-06-03')

# print(pred)

save_pickle(results, 'arima.pkl')
pickle.dump(results, open('arima.pkl', 'wb'))